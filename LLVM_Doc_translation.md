# 概要
このドキュメントは、LLVMアセンブリ言語のリファレンスマニュアルです。\
LLVMは、型安全性、低レベル操作、柔軟性、および「すべての」高水準言語をきれいに表現する能力を提供するスタティック・シングル・アサインメント（SSA）ベースの表現です。\
これは、LLVMコンパイル戦略の全フェーズで使用される共通コード表現です。

# はじめに
LLVMコード表現は、インメモリコンパイラIR、ディスク上のビットコード表現（Just-In-Timeコンパイラによる高速ロードに適しています）、
および人間が読めるアセンブリとしての3つの異なる形式で使用するように設計されています 。 \
これにより、LLVMは効率的なコンパイラの変換と解析のための強力な中間表現を提供し、変換をデバッグして視覚化する自然な手段を提供します。\
LLVMの3つの異なる形式はすべて同等です。 このドキュメントでは、人間が読める表現と表記について説明します。\

LLVM表現は、表現力、型付け性、および拡張性を同時に備えながら、軽量かつ低レベルを目指しています。 \
ハイレベルなアイデアがきちんとマッピングされるほど低いレベルにあることで、マイクロソフトがどのように「ユニバーサルIR」になっているかと同様に、
多くのソース言語をそれらにマッピングできるようにすることで、「普遍的なIR」を目指しています ）。\
タイプ情報を提供することで、LLVMを最適化のターゲットとして使用することができます。\
例えば、ポインタ解析によって、Cの自動変数が現在の関数の外部に決してアクセスされることはなく、メモリの場所ではなく単純なSSA値に昇格できることが分かります。

# よい形成
この文書では、「整形式」LLVMアセンブリ言語について説明しています。\ 
パーサーが受け入れるものと、「うまく形成された」とみなされるものには違いがあります。\ 
たとえば、次の命令は構文上問題ありませんが、正しく構成されていません。

``` %x = add i32 1, %x ```

％xの定義がそのすべての用途を支配していないからです。\
LLVMインフラストラクチャは、LLVMモジュールが整形式であることを検証するために使用される検証パスを提供する。 \
このパスは、入力アセンブリーを解析した後にパーサによって自動的に実行され、ビットコードを出力する前にオプティマイザによって自動的に実行されます。\
検証者パスによって指摘された違反は、変換パスのバグまたはパーサーへの入力を示します。\

# 識別子
LLVM識別子には、グローバルとローカルという2つの基本タイプがあります。\
グローバル識別子（関数、グローバル変数）は '@'文字で始まります。 \
ローカル識別子（レジスタ名、型）は '％'文字で始まります。\
さらに、異なる目的のために、識別子には3つの異なるフォーマットがあります。
1. 名前付きの値は、接頭辞付きの文字列として表されます。\
たとえば、％foo、@DivisionByZero、％a.really.long.identifierなどです。\
使用される実際の正規表現は '[％@] [ -  a-zA-Z $ ._] [ -  a-zA-Z $ ._ 0-9] *'です。\
名前に他の文字を必要とする識別子は、引用符で囲むことができます。 特殊文字は "\ xx"を使用してエスケープできます。ここで、xxは16進数の文字のASCIIコードです。 \
このようにして、任意の文字を名前の値に使用することができます。\
"\ 01"接頭辞は、マングリングを抑制するためにグローバル変数で使用できます。


2. 未使用の値は、接頭辞が付いた符号なし数値で表されます。 たとえば、％12、@ 2、％44などです。

3. 定数。以下の節で説明します。

LLVMは、値がプレフィックスで始まることを2つの理由から要求しています。\
コンパイラは予約語で名前の衝突を心配する必要はなく、予約語のセットは将来ペナルティなしに展開されます。 \
さらに、名前のない識別子を使用すると、コンパイラはシンボルテーブルの競合を避けることなく、一時変数をすぐに思い付くことができます。


LLVMの予約語は、他の言語の予約語と非常によく似ています。\
プリミティブ型の名前（ 'void'、 'i32'など）、その他のために、さまざまなオペコード（ 'add'、 'bitcast'、 'ret'など）のキーワードがあります。\
これらの予約語は、接頭辞文字（ '％'または '@'）で始まるものがないため、変数名と競合することはできません。

次に整数変数 '％X'に8を掛けるLLVMコードの例を示します。
簡単な方法：
```%result = mul i32 %X, 8```
強度低下後：
``` %result = shl i32 %X, 3 ```
難しい方法
```
%0 = add i32 %X, %X           ; yields i32:%0
%1 = add i32 %0, %0           ; yields i32:%1
%result = add i32 %1, %1
```

メモ: 12/16 二元 e201
