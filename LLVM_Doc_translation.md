# 概要
このドキュメントは、LLVMアセンブリ言語のリファレンスマニュアルです。\
LLVMは、型安全性、低レベル操作、柔軟性、および「すべての」高水準言語をきれいに表現する能力を提供するスタティック・シングル・アサインメント（SSA）ベースの表現です。\
これは、LLVMコンパイル戦略の全フェーズで使用される共通コード表現です。

# はじめに
LLVMコード表現は、インメモリコンパイラIR、ディスク上のビットコード表現（Just-In-Timeコンパイラによる高速ロードに適しています）、
および人間が読めるアセンブリとしての3つの異なる形式で使用するように設計されています 。 \
これにより、LLVMは効率的なコンパイラの変換と解析のための強力な中間表現を提供し、変換をデバッグして視覚化する自然な手段を提供します。\
LLVMの3つの異なる形式はすべて同等です。 このドキュメントでは、人間が読める表現と表記について説明します。\

LLVM表現は、表現力、型付け性、および拡張性を同時に備えながら、軽量かつ低レベルを目指しています。 \
ハイレベルなアイデアがきちんとマッピングされるほど低いレベルにあることで、マイクロソフトがどのように「ユニバーサルIR」になっているかと同様に、
多くのソース言語をそれらにマッピングできるようにすることで、「普遍的なIR」を目指しています ）。\
タイプ情報を提供することで、LLVMを最適化のターゲットとして使用することができます。\
例えば、ポインタ解析によって、Cの自動変数が現在の関数の外部に決してアクセスされることはなく、メモリの場所ではなく単純なSSA値に昇格できることが分かります。

# よい形成
この文書では、「整形式」LLVMアセンブリ言語について説明しています。\ 
パーサーが受け入れるものと、「うまく形成された」とみなされるものには違いがあります。\ 
たとえば、次の命令は構文上問題ありませんが、正しく構成されていません。

``` %x = add i32 1, %x ```

％xの定義がそのすべての用途を支配していないからです。\
LLVMインフラストラクチャは、LLVMモジュールが整形式であることを検証するために使用される検証パスを提供する。 \
このパスは、入力アセンブリーを解析した後にパーサによって自動的に実行され、ビットコードを出力する前にオプティマイザによって自動的に実行されます。\
検証者パスによって指摘された違反は、変換パスのバグまたはパーサーへの入力を示します。\

メモ: 12/16 二元 e201
